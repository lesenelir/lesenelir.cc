import { Prism as SyntaxHighlighter } from 'react-syntax-highlighter'
import { nord } from 'react-syntax-highlighter/dist/cjs/styles/prism'

import ImageInMDX from '../../../components/utils/ImageInMDX'
import AtomLightImage from '../images/2024-04-01/atom-dep.png'
import AtomDarkImage from '../images/2024-04-01/atom-dep-dark.png'

坦白来说，我不是很喜欢我取的这个标题，或许是出自于以前错误学编程时抱着「xxx理念与实践」砖头书的恐惧，
每每看到介绍某种技术又取名为「xxx理念与技术」我都会想起那些砖头书的厚度和枯燥程度... 但这个标题又是我这篇文章想要表达的，所以就先这样吧。

这篇文章主要介绍我对 Jotai 的一些理解和实践。其实很多时候，我写技术类文章的目的并不是给别人看的，主要是为了自己梳理一遍思路，
同时也是为了记录，以便日后查阅。当然，如果这篇文章能对你有所启发和帮助，那就更好不过了。

> 由于个人能力和经验的局限，以下内容虽然是个人理解，但我不能保证完全正确，还请读者酌情阅读。

---

我最早用 Jotai 是在 23 年 12 月，当时我在写一个 `AI Space` 项目。那时候对「状态」的理解都不是很深，只是有个需求需要在组件间共享状态值，且这两个组件是处于「混乱关系」（组件间不是很明确的父子关系，且最近公共祖先节点极远），与此同时听说过 Jotai 这个库，所以就尝试用了一下。

`AI Space` 中使用的 Jotai 相关代码：[AI-Space Atoms](https://github.com/lesenelir/ai-space/blob/master/src/atoms/index.ts) 。

如果你点进去，会发现这个文件夹内定义了大量的全局变量 `Atom` （原子）。可以想象，当你的项目规模开始变大，你每次都需要在这个文件内定义一个全局变量，那么长此以往，你的代码会变得非常难以维护，因为这些全局变量的使用是分散的，同时你还需要考虑命名冲突的问题，更重要的是没有用到 Jotai 核心概念：`Derived Atom`（派生原子）。这些都是我当时写项目没有考虑到错误使用 Jotai 的点。

这两天又重新看了 Jotai 的文档，同时又看到知乎上的一篇文章 [React生态：深入探讨Jotai和Bunshi的思想、实现与实践](https://zhuanlan.zhihu.com/p/660476762) 写的极其出彩，所以又重新做了一些 Jotai 的相关实践。
这篇文章不会阐述「状态」这个概念在 React 项目中是如何重要的，如果你想在这方面了解更多，可以阅读上述的知乎文章，那里面有对状态汇总做了简单描述。我这篇文章只会聚焦于 Jotai，并结合官方文档、上述的知乎文章和我自己的实践，来谈谈我对 Jotai 的理解和实践。

这篇文章的代码可以在 [lesenelir/jotai-related](https://github.com/lesenelir/jotai-related) 中找到。

---

### 状态管理

简单写过 React 项目的人都知道，在 React 项目中，状态管理这个概念是非常重要的。可以说，很多项目的难点就在于对复杂状态的维护上。
而项目中的状态又不是仅仅由组件内部 `state` 来管理的。对于同一个状态值，我们可能需要把它在不同的组件中共享。如果当前需要共享状态的组件们是父子关系或可以通过`props`传递，即使传递的深度很深也没有太大问题，只要我们能明确每次交互的数据流转，那么我们写出来的 UI 都是可预测的。
但是如果这两个组件是处于上文描述的「混乱关系」（最近公共祖先节点极远）时，那么就需要用到一些状态管理库了。

这里有两个概念：「状态管理」和「全局状态管理」。

「状态管理」顾名思义就是管理状态，整合状态，使得状态更好维护。`useReducer` 就是一个状态管理 Hooks。

「全局状态管理」则是在状态管理的基础上，把状态值放到全局，使得任何组件都可以访问这个状态值。这样极大方便的让处于「混乱关系」组件间共享状态值，做到状态值的一致性。
但全局状态管理也有它的缺点，比如状态值的改变会导致所有依赖这个状态值的组件都重新渲染，这样会导致性能问题。
`useContext` 就是一种全局状态管理的实现方式。

### Jotai 核心

Jotai 是一种状态管理的工具。但我们一般会把 Jotai 当作一种全局状态管理工具，因为我们能在任意组件中都可以拿到原子对应的状态。

但这其实是一种<span className={'text-red-800'}>错误的说法</span>。

实际上，<span>Jotai 原子对应的状态是归属于每一个组件，即每一个组件都维护一份自己的状态。只不过这些状态都有相同的状态值，而这些<span className={'text-red-800'}>状态值</span>是全局共享。</span>
全局共享的不仅仅有状态值，还有每个组件对应这个状态值的 `setter` 方法。当你状态值改变后，就会去触发所有 `setter` 方法，这样既保证了这些组件一起 Re-Render，又保证了状态值的一致性。

所以，当我们说 Jotai 是一种全局状态管理工具时，其实是不准确的。因为 Jotai 并没有把状态放到全局，而是在每一个组件中都维护了一份状态。只不过 Jotai 是把这些状态对应相同的状态值放到了全局，所以我们可以把它看做一种全局的状态管理工具，但本质状态是由各个组件自己维护的。

上述描述的是 Jotai 的一个偏底层的实现，但在实际应用中，我们更应该关注 Jotai 的另一核心概念： `Atom` （原子）。

原子概念可以说是 Jotai 中的核心，具体来说我们可以把原子分为两类：

- `Primitive Atom` 原生原子
- `Derived   Atom` 派生原子
  - `Read-Only Derived Atom` 只读派生原子
  - `Write-Only Derived Atom` 只写派生原子
  - `Read Write Derived Atom` 可读可写派生原子

原子与原子之间是可以存在依赖关系的。原生原子是没有依赖的，而派生原子则是依赖于原生原子，也可以依赖于其他派生原子。[React生态：深入探讨Jotai和Bunshi的思想、实现与实践](https://zhuanlan.zhihu.com/p/660476762) 一文中，把 jotai 的依赖关系当作一个有向无环图。
那么，原生原子就是顶层的节点，派生原子就是指向原生原子的节点。
当原生原子的值发生变化时，会通知所有依赖于它的派生原子，这些派生原子会重新计算自己的值，然后通知依赖于它们的派生原子，这样一层层地传递下去，直到所有派生原子都计算完毕。所以，当派生原子依赖的原生原子越多时，则当前派生原子发生改变的几率也就越大。
如下图所示：

<ImageInMDX
  dark={{
    src: AtomDarkImage,
    alt: 'image in dark mode'
  }}
  light={{
    src: AtomLightImage,
    alt: 'image in light mode'
  }}
/>

具体来说，当 `primitive atom 1` 的值发生改变时，会通知 `derived atom 1` 和 `derived atom 2`，`derived atom 1` 和 `derived atom 2` 会重新计算自己的值，由于 `derived atom 3` 依赖于 `derived atom 2`，所以当 `derived atom 2` 的值发生改变时, `derived atom 3` 的值也会发生改变。同理，`primitive atom 2` 值发生改变，`derived atom 2` 和 `derived atom 3` 也会重新计算自己的值。

### read-only derived atom

首先，介绍只读派生原子。代码如下：

<SyntaxHighlighter language="typescript" style={nord}>
  {`type TAnime = {
  name: string
  episodes: number
  watched: boolean
}

export const animeAtom = atom<TAnime[]>([
  { name: 'Naruto', episodes: 220, watched: true},
  { name: 'One Piece', episodes: 1000, watched: false },
  { name: 'Dragon Ball', episodes: 153, watched: true }
])

export const watchedAnimeAtom = atom<TAnime[]>((get) => {
  const anime = get(animeAtom)
  return anime.filter((a) => a.watched)
})

export default function DocumentPage() {
  const watchedAnime = useAtomValue(watchedAnimeAtom)
  const setAnime = useSetAtom(animeAtom)

  const handleAddClick = () => {
    setAnime((prev: TAnime[]) => [
      ...prev,
      { name: 'Cowboy Bebop', episodes: 26, watched: true }
    ])
  }

  return (
    <div className={'flex gap-2'}>
      <div>
        <h1 className={'font-medium text-lg'}>Watched Anime:</h1>
        <ul>
          {watchedAnime.map((anime, index) => (
            <li key={index}>
              {anime.name}
            </li>
          ))}
        </ul>
      </div>

      <button
        className={'bg-blue-500 text-white px-4 py-2 rounded-lg'}
        onClick={handleAddClick}
      >
        Add Cowboy Bebop
      </button>
    </div>
  )
}
`}
</SyntaxHighlighter>

这段代码是 [官网文档 Primitive atoms](https://jotai.org/) 中某一个例子的扩展。

首先定义了一个 `animeAtom` 原生原子，其次再定义了一个 `watchedAnimeAtom` 派生原子，同时它也是一个只读派生原子。可以看出，`watchedAnimeAtom` 依赖于 `animeAtom`，它会过滤掉 `animeAtom` 中 `watched` 为 `false` 的元素，得到一个新的只读原子。
这个例子中，点击 `button` 触发 `animeAtom` 的值改变，`watchedAnimeAtom` 也会重新计算自己的值，触发 Re-Render。

对于只读派生原子而言，可以通过 `useAtomValue` 来获取它的值。需要注意的是：只能通过修改原生原子的值来触发只读派生原子状态值改变。因为只读派生原子本身是没有 `setter` 方法，不能利用 `useSetAtom(readOnlyDerivedAtom)` 来修改它的值。

综上所述，对于只读派生原子而言：
- 通过 `get` 方法获取派生原子依赖原生原子的状态值， `get` 用于订阅某种依赖关系。
- 该类原子本身值不能修改，只能靠依赖的原生原子值变化来触发重新计算，所以不能通过 `useSetAtom` 来使用。


### write-only derived atom

介绍只写派生原子。代码如下：

<SyntaxHighlighter language="typescript" style={nord}>
  {`export const priceAtom = atom<number>(10)

export const writeOnlyPriceAtom = atom<
  null,
  [{type: string, data: number}],
  void
>(
  null,
  (get, set, update: {type: string, data: number}) => {
    // set(priceAtom, price => price + update.data)
    const primitivePrice = get(priceAtom)
    set(priceAtom, primitivePrice + update.data)
  }
)

export default function Page() {
  const setWriteOnlyPriceAtom = useSetAtom(writeOnlyPriceAtom)

  return (
    <div className={'flex flex-col gap-2'}>
      <button
        className={'bg-blue-500 text-white px-4 py-2 rounded-lg w-fit'}
        onClick={() => setWriteOnlyPriceAtom({ type: 'add', data: 10})}
      >
        Add
      </button>
    </div>
  )
}
`}
</SyntaxHighlighter>

atom 函数接受两个参数，这两个参数都是函数。第一个函数是 `getter` 函数，用于获取依赖的原生原子的状态值，该函数 return 出去的值是当前派生原子的状态值。
第二个函数是一个 `setter` 函数，`get` 参数用于获取其他原子的状态值，`set` 参数用于修改其他原子的状态值，第三个参数是 `...args`，在源码中是用 args 数组进行接收。

上述代码，定义了一个 `writeOnlyPriceAtom` 只写派生原子，它依赖于 `priceAtom` 原生原子。`writeOnlyPriceAtom` 本身没有状态值，只有一个 `setter` 方法，用于修改 `priceAtom` 的值。

需要注意的是，只写派生原子是没有状态值的，它只有一个更新函数，定义了如何去更新其他原子的状态。这里引出一个问题：为什么需要只写派生原子呢？

个人的理解，Jotai 是作为状态管理库，而不是全局状态管理库。如果是一个全局状态管理库，那肯定是需要每一个原子都有一个状态对应，但 Jotai 作为一个状态管理库，它的核心就是为了更好的方便管理状态。
例如，一次交互需要有多个状态更新，则可以将这些更新逻辑都封装到一个只写原子中，而不是在组件内部去处理这些逻辑。这样可以更好的把状态管理逻辑和 UI 逻辑分离开来，使得代码更加清晰。

比如，在上述的 `writeOnlyPriceAtom` 中只对一个原子的状态进行了更新，看似和直接调用 `useSetAtom(priceAtom)` 没有太大区别，但这里直接把更新逻辑封装到了一个原子中，而这部分逻辑就可以直接从组件中抽离出来。
尤其当你的某次交互需要更新多个原子状态，即 `setter` 函数中有多次 set 方法的调用，只写派生原子就显得更加方便了。


### read write derived atom

上述两小节分别介绍了只读派生原子和只写派生原子。这一节介绍可读可写派生原子。介绍可读可写派生原子前，对于一个原生原子，它既是可读原子，又是可写原子。

如何分辨某个原子是属于哪种类型的原子呢？这里有一个简单的规则：

如果一个 atom 函数只有第一个参数，那么它就是一个可读原子。如果一个 atom 函数只有第二个参数，那么它就是一个可写原子。如果一个 atom 函数同时有第一个和第二个参数函数或只有一个原始值参数，那么它就是一个可读可写原子。
对于只读原子，可以通过 `useAtomValue` 来获取它的状态值；对于只写原子，原子本身不包含状态，可以通过 `useSetAtom` 来获取它的 `setter` 方法。
对于可读可写原子，可以通过 `useAtom` 来获取它的状态值和 `setter` 方法。

具体的可读可写派生原子代码如下：

<SyntaxHighlighter language="typescript" style={nord}>
  {`export const userScoreAtom = atom<number>(0)

export const readWriteUserLevelAtom = atom<
  string,
  ['+' | '-'],
  void
>(
  (get) => {
    const score = get(userScoreAtom)
    if (score < 60) {
      return 'Beginner'
    } else if (score < 80) {
      return 'Intermediate'
    } else {
      return 'Expert'
    }
  },
  (get, set, update: '+' | '-') => {
    const currentScore = get(userScoreAtom)

      let newScore

      switch (update) {
        case "+":
          newScore = currentScore + 10
          break
        case "-":
          newScore = currentScore - 10
          break
        default:
          newScore = currentScore
      }
      set(userScoreAtom, newScore)
    }
  )

export default function Page() {
  const userScore = useAtomValue(userScoreAtom)
  const [userLevel, setUserLevel] = useAtom(readWriteUserLevelAtom)

  return (
    <div className={'p-2 flex flex-col gap-2'}>
      <p>{userScore}</p>
      <p>{userLevel}</p>

      <button
        className={'w-fit bg-blue-500 text-white px-4 py-2 rounded-lg'}
        onClick={() => setUserLevel('+')}
      >
        +
      </button>

      <button
        className={'w-fit bg-blue-500 text-white px-4 py-2 rounded-lg'}
        onClick={() => setUserLevel('-')}
      >
        -
      </button>
    </div>
  )
}
`}
</SyntaxHighlighter>

可以看到 `readWriteUserLevelAtom` 中，定义了一个可读可写派生原子。它依赖于 `userScoreAtom` 原生原子。
`readWriteUserLevelAtom` 有一个 `getter` 函数，该原子会依赖于 `userScoreAtom` 的状态值，根据 `userScoreAtom` 的值来计算当前用户等级，并将这个值作为该可读可写派生原子的状态值。
同时它有一个 `setter` 函数，用于执行该原子的更新逻辑。在这个例子中，点击 `+` 按钮会使 `userScoreAtom` 的值加 10，点击 `-` 按钮会使 `userScoreAtom` 的值减 10。

你可能会问，为什么在 `readWriteUserLevelAtom` 中，需要 `setter` 函数呢？为什么不能直接在组件中调用 `useSetAtom(userScoreAtom)` 来更新 `userScoreAtom` 的值呢？

其实，这个问题和上一节介绍的只写派生原子是一样的。只写派生原子是为了把更新逻辑封装到一个原子中，使得代码更加清晰。而可读可写派生原子也是一样的，它是为了把计算逻辑和更新逻辑封装到一个原子中，使得代码更加清晰。
在这里就不需要在组件内再写 `useSetAtom(userScoreAtom)` 中的更新逻辑，做到了组件内部尽可能关注 UI 逻辑，而状态管理逻辑则封装到了原子中。


### atom 实践

这一节会结合上述撰写的派生原子概念，实现一个简单的登录相关的状态管理。

在写这个例子前，需要知道 atom 中的两个参数函数可以是异步的。这就意味着你可以在 `getter` 函数中执行异步操作，比如请求后端数据，然后返回一个 Promise。这样就可以实现异步状态管理。


<span className={'text-2xl text-blue-500'}>
  未完待续...
</span>





